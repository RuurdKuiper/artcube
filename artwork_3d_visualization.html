<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artwork 3D Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            min-width: 250px;
            backdrop-filter: blur(10px);
        }

        #controls h2 {
            margin-bottom: 15px;
            color: #fff;
            font-size: 18px;
        }

        .axis-control {
            margin-bottom: 15px;
        }

        .axis-control label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ccc;
        }

        .axis-control select {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
        }

        .axis-control select:hover {
            background: #333;
        }

        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            min-width: 200px;
            backdrop-filter: blur(10px);
        }

        #legend h3 {
            margin-bottom: 10px;
            font-size: 14px;
            color: #fff;
        }

        #legend-content {
            font-size: 12px;
            color: #ccc;
        }

        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 10px;
            pointer-events: none;
            z-index: 1000;
            max-width: 400px;
            display: none;
            border: 2px solid #555;
            backdrop-filter: blur(10px);
        }

        #tooltip-image {
            width: 100%;
            max-width: 300px;
            height: auto;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #tooltip-title {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }

        #tooltip-info {
            font-size: 13px;
            color: #ccc;
            line-height: 1.6;
        }

        #tooltip-info div {
            margin-bottom: 3px;
        }

        #axis-labels {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .axis-label {
            position: absolute;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .axis-label.x-axis {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
        }

        .axis-label.y-axis {
            left: 30px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
        }

        .axis-label.z-axis {
            top: 30px;
            right: 30px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <div id="controls">
            <h2>Axis Controls</h2>
            <div class="axis-control">
                <label for="x-axis">X Axis:</label>
                <select id="x-axis">
                    <option value="year">Year</option>
                    <option value="type">Type</option>
                    <option value="region">Region</option>
                </select>
            </div>
            <div class="axis-control">
                <label for="y-axis">Y Axis:</label>
                <select id="y-axis">
                    <option value="type">Type</option>
                    <option value="year">Year</option>
                    <option value="region">Region</option>
                </select>
            </div>
            <div class="axis-control">
                <label for="z-axis">Z Axis:</label>
                <select id="z-axis">
                    <option value="region">Region</option>
                    <option value="year">Year</option>
                    <option value="type">Type</option>
                </select>
            </div>
        </div>

        <div id="legend">
            <h3>Color Scale (Z-Axis)</h3>
            <div id="legend-content"></div>
        </div>

        <div id="tooltip">
            <img id="tooltip-image" src="" alt="Artwork">
            <div id="tooltip-title"></div>
            <div id="tooltip-info"></div>
        </div>

        <div id="axis-labels">
            <div class="axis-label x-axis" id="x-axis-label">X Axis</div>
            <div class="axis-label y-axis" id="y-axis-label">Y Axis</div>
            <div class="axis-label z-axis" id="z-axis-label">Z Axis</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let artworks = [];
        let metadata = {};
        let points = [];
        let raycaster, mouse;
        let currentAxes = { x: 'year', y: 'type', z: 'region' };
        let hoveredPoint = null;

        // Initialize
        async function init() {
            // Load data
            const response = await fetch('artwork_data_processed.json');
            const data = await response.json();
            artworks = data.artworks;
            metadata = data.metadata;

            console.log(`Loaded ${artworks.length} artworks`);

            // Setup scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Setup camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            // Setup renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Setup controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Setup raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Setup event listeners
            setupEventListeners();

            // Create initial visualization
            updateVisualization();

            // Start animation loop
            animate();
        }

        function setupEventListeners() {
            // Axis dropdowns
            document.getElementById('x-axis').addEventListener('change', (e) => {
                currentAxes.x = e.target.value;
                updateVisualization();
            });
            document.getElementById('y-axis').addEventListener('change', (e) => {
                currentAxes.y = e.target.value;
                updateVisualization();
            });
            document.getElementById('z-axis').addEventListener('change', (e) => {
                currentAxes.z = e.target.value;
                updateVisualization();
            });

            // Mouse move for tooltip
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onMouseClick);

            // Window resize
            window.addEventListener('resize', onWindowResize);
        }

        function compressBceYear(yearValue, minBce, maxCe) {
            if (yearValue < 0) { // BCE
                const bceRange = Math.abs(minBce);
                if (bceRange === 0) return 0.05;
                const normalized = (Math.abs(yearValue) / bceRange) * 0.1;
                return normalized;
            } else { // CE
                const ceRange = maxCe;
                if (ceRange === 0) return 0.5;
                const normalized = 0.1 + ((yearValue / ceRange) * 0.9);
                return normalized;
            }
        }

        function getAxisValue(artwork, axisType) {
            switch (axisType) {
                case 'year':
                    const yearValue = artwork.year.value;
                    return compressBceYear(
                        yearValue,
                        metadata.year_range.min_bce,
                        metadata.year_range.max_ce
                    );
                case 'type':
                    return artwork.type.index / (metadata.type_count - 1 || 1);
                case 'region':
                    return artwork.region.index / (metadata.region_count - 1 || 1);
                default:
                    return 0;
            }
        }

        function getAxisLabel(axisType) {
            switch (axisType) {
                case 'year':
                    return 'Year (BCE compressed to 10%)';
                case 'type':
                    return 'Type';
                case 'region':
                    return 'Region';
                default:
                    return axisType;
            }
        }

        function getColorForZAxis(value, axisType) {
            if (axisType === 'year') {
                // Color scale for year (blue to red)
                return new THREE.Color().setHSL(0.6 - (value * 0.6), 0.8, 0.5);
            } else if (axisType === 'type') {
                // Color scale for type
                return new THREE.Color().setHSL(value * 0.8, 0.8, 0.5);
            } else if (axisType === 'region') {
                // Color scale for region
                return new THREE.Color().setHSL(value * 0.6, 0.8, 0.5);
            }
            return new THREE.Color(0xffffff);
        }

        function updateVisualization() {
            // Clear existing points
            points.forEach(point => {
                scene.remove(point);
            });
            points = [];

            // Update axis labels
            document.getElementById('x-axis-label').textContent = getAxisLabel(currentAxes.x);
            document.getElementById('y-axis-label').textContent = getAxisLabel(currentAxes.y);
            document.getElementById('z-axis-label').textContent = getAxisLabel(currentAxes.z);

            // Update legend
            updateLegend();

            // Scale factor for visualization
            const scale = 10;

            // Create points
            artworks.forEach((artwork, index) => {
                const x = getAxisValue(artwork, currentAxes.x) * scale;
                const y = getAxisValue(artwork, currentAxes.y) * scale;
                const z = getAxisValue(artwork, currentAxes.z) * scale;

                // Create sphere geometry
                const geometry = new THREE.SphereGeometry(0.15, 16, 16);
                const zValue = getAxisValue(artwork, currentAxes.z);
                const color = getColorForZAxis(zValue, currentAxes.z);
                const material = new THREE.MeshBasicMaterial({ color: color });
                const sphere = new THREE.Mesh(geometry, material);

                sphere.position.set(x, y, z);
                sphere.userData = { artwork: artwork, index: index };

                scene.add(sphere);
                points.push(sphere);
            });

            // Add axes helpers
            addAxesHelpers(scale);
        }

        function addAxesHelpers(scale) {
            // Remove existing helpers
            const existingHelpers = scene.children.filter(child => child.userData.isHelper);
            existingHelpers.forEach(helper => scene.remove(helper));

            // X axis (red)
            const xHelper = new THREE.ArrowHelper(
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(0, 0, 0),
                scale * 1.1,
                0xff0000,
                scale * 0.1,
                scale * 0.05
            );
            xHelper.userData.isHelper = true;
            scene.add(xHelper);

            // Y axis (green)
            const yHelper = new THREE.ArrowHelper(
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, 0, 0),
                scale * 1.1,
                0x00ff00,
                scale * 0.1,
                scale * 0.05
            );
            yHelper.userData.isHelper = true;
            scene.add(yHelper);

            // Z axis (blue)
            const zHelper = new THREE.ArrowHelper(
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, 0),
                scale * 1.1,
                0x0000ff,
                scale * 0.1,
                scale * 0.05
            );
            zHelper.userData.isHelper = true;
            scene.add(zHelper);
        }

        function updateLegend() {
            const legendContent = document.getElementById('legend-content');
            const zAxisType = currentAxes.z;

            if (zAxisType === 'year') {
                legendContent.innerHTML = `
                    <div>Blue: BCE (compressed)</div>
                    <div>Red: Modern CE</div>
                `;
            } else if (zAxisType === 'type') {
                const types = metadata.types;
                let html = '<div style="margin-top: 5px;">';
                types.forEach((type, i) => {
                    const color = getColorForZAxis(i / (types.length - 1 || 1), 'type');
                    const hexColor = '#' + color.getHexString();
                    html += `<div style="color: ${hexColor}">● ${type}</div>`;
                });
                html += '</div>';
                legendContent.innerHTML = html;
            } else if (zAxisType === 'region') {
                const regions = metadata.regions;
                let html = '<div style="margin-top: 5px;">';
                regions.forEach((region, i) => {
                    const color = getColorForZAxis(i / (regions.length - 1 || 1), 'region');
                    const hexColor = '#' + color.getHexString();
                    html += `<div style="color: ${hexColor}">● ${region}</div>`;
                });
                html += '</div>';
                legendContent.innerHTML = html;
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(points);

            const tooltip = document.getElementById('tooltip');

            if (intersects.length > 0) {
                const point = intersects[0].object;
                const artwork = point.userData.artwork;

                if (hoveredPoint !== point) {
                    hoveredPoint = point;
                    showTooltip(artwork, event.clientX, event.clientY);
                }
            } else {
                if (hoveredPoint) {
                    hoveredPoint = null;
                    tooltip.style.display = 'none';
                }
            }
        }

        function showTooltip(artwork, mouseX, mouseY) {
            const tooltip = document.getElementById('tooltip');
            const tooltipImage = document.getElementById('tooltip-image');
            const tooltipTitle = document.getElementById('tooltip-title');
            const tooltipInfo = document.getElementById('tooltip-info');

            // Set image
            tooltipImage.src = artwork.image_filename;
            tooltipImage.onerror = function() {
                this.style.display = 'none';
            };
            tooltipImage.onload = function() {
                this.style.display = 'block';
            };

            // Set title
            tooltipTitle.textContent = artwork.title;

            // Set info
            tooltipInfo.innerHTML = `
                <div><strong>Artist:</strong> ${artwork.artist}</div>
                <div><strong>Year:</strong> ${artwork.year.display}</div>
                <div><strong>Type:</strong> ${artwork.type.name}</div>
                <div><strong>Region:</strong> ${artwork.region.name}</div>
                <div><strong>Medium:</strong> ${artwork.medium}</div>
            `;

            // Position tooltip
            tooltip.style.display = 'block';
            const tooltipWidth = 400;
            const tooltipHeight = 500;
            let left = mouseX + 20;
            let top = mouseY + 20;

            // Adjust if off-screen
            if (left + tooltipWidth > window.innerWidth) {
                left = mouseX - tooltipWidth - 20;
            }
            if (top + tooltipHeight > window.innerHeight) {
                top = mouseY - tooltipHeight - 20;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(points);

            if (intersects.length > 0) {
                const artwork = intersects[0].object.userData.artwork;
                if (artwork.wikipedia_url) {
                    window.open(artwork.wikipedia_url, '_blank');
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Start the application
        init();
    </script>
</body>
</html>
